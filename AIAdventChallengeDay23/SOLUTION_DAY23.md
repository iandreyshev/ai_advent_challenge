# День 23: Ассистент команды разработки

## Выполненное задание

Создан **ассистент команды разработки TaskFlow**, который объединяет RAG, MCP и возможности работы с задачами.

### Реализованный функционал

✅ **RAG (Retrieval-Augmented Generation)**
- Индексация документации о работе с задачами и управлении командой
- Векторный поиск через Ollama embeddings (nomic-embed-text)
- Контекстные ответы на основе документации

✅ **MCP (Model Context Protocol) - 5 инструментов**
1. `get_user_info` - информация о члене команды
2. `get_task` - детальная информация о задаче
3. `get_user_tasks` - все задачи пользователя
4. `search_tasks` - поиск задач по фильтрам (projectId, assigneeId, status, priority)
5. `create_task` - создание новой задачи через API

✅ **Анализ статуса проекта**
- Автоматическое получение задач с высоким приоритетом
- Анализ заблокированных задач
- Информация о задачах в работе

✅ **Рекомендации по приоритетам**
- Анализ приоритетов и дедлайнов
- Выявление блокирующих задач
- Рекомендации по порядку выполнения задач
- Учет загруженности команды

✅ **Настраиваемая температура**
- Контроль креативности ответов модели
- Разные значения для разных типов запросов
- По умолчанию 0.7 (сбалансированный режим)

## Архитектура

```
AIAdventChallengeDay23/
├── tasks-mcp/                      # MCP-сервер
│   ├── src/main/kotlin/
│   │   ├── Application.kt          # Ktor приложение
│   │   ├── MCPServer.kt            # 5 MCP tools для работы с задачами
│   │   └── Routing.kt              # REST API endpoints
│   └── src/main/resources/
│       ├── tasks.json              # База данных задач
│       └── docs/
│           ├── team_management.txt # Документация по приоритизации
│           ├── tasks.txt           # Документация по задачам
│           └── ...
│
└── team-assistant/                 # Клиентское приложение
    └── src/main/kotlin/ru/iandreyshev/assistant/
        ├── Main.kt                 # Тестовые запросы
        ├── SupportAssistant.kt     # Главный класс с логикой рекомендаций
        ├── RAGSystem.kt            # RAG поиск
        ├── VectorStore.kt          # Векторная БД
        └── OllamaClient.kt         # Клиент для Ollama
```

## Структура данных

### Задачи (tasks.json)
```json
{
  "users": [...],        // Члены команды (developer, frontend, qa, lead)
  "projects": [...],     // Проекты (TaskFlow Core, TaskFlow Mobile)
  "tasks": [             // 10 тестовых задач
    {
      "id": "task001",
      "projectId": "proj001",
      "title": "Исправить баг с OAuth авторизацией",
      "status": "in_progress",
      "priority": "high",
      "assigneeId": "user001",
      "dueDate": "2026-01-16T18:00:00Z",
      "tags": ["bug", "oauth", "authentication"],
      "estimatedHours": 4
    }
  ]
}
```

### Статусы задач
- `todo` - готова к выполнению
- `in_progress` - в работе
- `blocked` - заблокирована (с указанием причины)
- `done` - завершена

### Приоритеты
- `urgent` - критические баги
- `high` - важные задачи
- `medium` - обычные задачи
- `low` - некритичные улучшения

## MCP Tools

### 1. get_user_info
Получение информации о члене команды
```json
{
  "userId": "user001"
}
```

### 2. get_task
Детали конкретной задачи
```json
{
  "taskId": "task001"
}
```

### 3. get_user_tasks
Все задачи пользователя (отсортированы по приоритету)
```json
{
  "userId": "user001"
}
```

### 4. search_tasks
Поиск задач по фильтрам
```json
{
  "priority": "high",
  "status": "in_progress",
  "projectId": "proj001"
}
```

### 5. create_task
Создание новой задачи
```json
{
  "projectId": "proj001",
  "title": "Новая задача",
  "description": "Описание",
  "priority": "medium",
  "assigneeId": "user001",
  "createdBy": "user003",
  "dueDate": "2026-01-20T18:00:00Z",
  "tags": "feature,backend",
  "estimatedHours": 8
}
```

## Как работает нативный tool calling

### Архитектура взаимодействия

```
┌─────────────────┐
│  Вопрос юзера   │
└────────┬────────┘
         │
         v
┌─────────────────┐
│  RAG: поиск     │
│  в документации │
└────────┬────────┘
         │
         v
┌─────────────────────────────────────┐
│  llama3.2 получает:                 │
│  • Вопрос пользователя              │
│  • Контекст из документации (RAG)   │
│  • Список из 5 MCP инструментов     │
└────────┬────────────────────────────┘
         │
         v
┌─────────────────────────────────────┐
│  llama3.2 анализирует и решает      │
│  какие инструменты вызвать          │
└────────┬────────────────────────────┘
         │
         v
┌─────────────────────────────────────┐
│  Вызов MCP инструмента              │
│  (например, search_tasks)           │
└────────┬────────────────────────────┘
         │
         v
┌─────────────────────────────────────┐
│  llama3.2 получает результат        │
│  Решает: достаточно данных?         │
└────────┬────────────────────────────┘
         │
         ├─ НЕТ ──> Вызов еще инструментов
         │
         v ДА
┌─────────────────────────────────────┐
│  llama3.2 генерирует финальный      │
│  ответ на основе всех данных        │
└─────────────────────────────────────┘
```

### Пример цепочки вызовов

**Вопрос:** "Покажи задачи с приоритетом high и предложи, что делать первым"

**Цепочка действий llama3.2:**
1. **Анализ вопроса** → нужны задачи с high приоритетом
2. **Вызов #1:** `search_tasks(priority="high")`
3. **Анализ результата** → получены 4 задачи, нужно проверить блокеры
4. **Вызов #2:** `search_tasks(status="blocked")`
5. **Анализ результата** → есть 1 заблокированная задача
6. **Решение:** достаточно данных для рекомендации
7. **Генерация ответа** с приоритизацией и обоснованием

### Преимущества подхода

❌ **Старый подход (ручной):**
```kotlin
// Разработчик жестко кодирует логику
val highPriority = search_tasks(priority="high")
val blocked = search_tasks(status="blocked")
val inProgress = search_tasks(status="in_progress")
// Всегда вызываются все 3, даже если не нужно
```

✅ **Новый подход (tool calling):**
```kotlin
// Модель сама решает что нужно
// Для простого вопроса → 1 вызов
// Для сложного вопроса → множественные вызовы
// Адаптивно под конкретную ситуацию
```

## Примеры работы

### Запрос 1: Приоритизация задач
**Вопрос:** "Покажи задачи с приоритетом high и предложи, что делать первым"

**Ответ ассистента:**
- Показывает все задачи с высоким приоритетом
- Анализирует дедлайны
- Выявляет блокирующие задачи
- Дает конкретные рекомендации по порядку выполнения

### Запрос 2: Статус пользователя
**Вопрос:** "Какие задачи у Ивана Петрова? Что он сейчас делает?"

**Ответ ассистента:**
- Информация о пользователе (роль, команда)
- Список всех его задач
- Выделяет задачи в работе
- Показывает приоритеты и дедлайны

### Запрос 3: Детали задачи
**Вопрос:** "Расскажи про задачу task001 - что там с багом OAuth?"

**Ответ ассистента:**
- Полная информация о задаче
- Контекст из документации по OAuth
- Статус и приоритет
- Информация об исполнителе

### Запрос 4: Анализ проекта
**Вопрос:** "Какой статус проекта TaskFlow Core? Есть ли проблемные задачи?"

**Ответ ассистента:**
- Анализирует все задачи проекта
- Выявляет задачи с высоким приоритетом
- Показывает заблокированные задачи
- Дает рекомендации

### Запрос 5: Блокеры
**Вопрос:** "Какие задачи заблокированы и почему?"

**Ответ ассистента:**
- Список всех заблокированных задач
- Причины блокировки
- Рекомендации по разблокировке
- Приоритизация разрешения блокеров

## Запуск

### Требования
- JDK 17+
- Ollama с моделями:
  - `nomic-embed-text` (для RAG embeddings)
  - `llama3.2` (для генерации с нативным tool calling)

### 1. Установка Ollama
```bash
# macOS
brew install ollama

# Запуск
ollama serve

# Загрузка моделей
ollama pull nomic-embed-text  # Для RAG embeddings
ollama pull llama3.2          # Для генерации с tool calling
```

### 2. Запуск MCP-сервера
```bash
cd tasks-mcp
./gradlew run
```
Сервер запустится на `http://localhost:8080`

### 3. Запуск ассистента (в отдельном терминале)
```bash
cd team-assistant
./gradlew run
```

Ассистент:
1. Подключится к Ollama
2. Проиндексирует документацию (включая team_management.txt)
3. Запустит 5 тестовых запросов
4. Покажет результаты с рекомендациями

## Тестирование MCP API

### Получить информацию о пользователе
```bash
curl -X POST http://localhost:8080/api/get_user_info \
  -H "Content-Type: application/json" \
  -d '{"userId":"user001"}'
```

### Поиск задач с высоким приоритетом
```bash
curl -X POST http://localhost:8080/api/search_tasks \
  -H "Content-Type: application/json" \
  -d '{"priority":"high"}'
```

### Создать новую задачу
```bash
curl -X POST http://localhost:8080/api/create_task \
  -H "Content-Type: application/json" \
  -d '{
    "projectId": "proj001",
    "title": "Написать тесты для нового модуля",
    "description": "Покрыть тестами модуль авторизации",
    "priority": "high",
    "assigneeId": "user001",
    "createdBy": "user003",
    "dueDate": "2026-01-18T18:00:00Z",
    "tags": "testing,quality",
    "estimatedHours": 6
  }'
```

## Интеллектуальные возможности

### RAG для контекста
Ассистент использует документацию для ответов:
- `team_management.txt` - правила приоритизации, работа с блокерами
- `tasks.txt` - как работать с задачами в TaskFlow
- Другие документы для дополнительного контекста

### Нативное подключение MCP к llama3.2
**Ключевая особенность**: MCP инструменты подключены напрямую к модели через tool calling API

**Как это работает:**
1. Модель llama3.2 получает определения всех 5 MCP инструментов
2. При обработке запроса модель **сама решает** какие инструменты нужно вызвать
3. Модель может делать **множественные вызовы** инструментов последовательно
4. Модель **анализирует результаты** инструментов и решает нужны ли дополнительные вызовы
5. Только после получения всех необходимых данных модель генерирует финальный ответ

**Преимущества нативного подключения:**
- Модель сама определяет **что** и **когда** нужно вызвать
- Не требуется предопределенная логика вызовов
- Модель может делать сложные цепочки вызовов
- Более гибкая адаптация к разным типам вопросов

### Анализ и рекомендации
llama3.2 анализирует данные из MCP инструментов:
- **Приоритеты**: urgent > high > medium > low
- **Дедлайны**: задачи с близкими дедлайнами важнее
- **Блокеры**: заблокированные задачи требуют немедленного внимания
- **Зависимости**: сначала зависимости, потом зависимые задачи
- **Загруженность**: равномерное распределение по команде

### Контроль креативности через Temperature

Temperature определяет насколько "креативными" или "предсказуемыми" будут ответы:

**Значения temperature:**
```
0.0 ──────── 0.3 ──────── 0.5 ──────── 0.7 ──────── 1.0+
│            │            │            │            │
Точные      Консер-     Сбаланси-    Креатив-    Очень
ответы      вативные    рованные     ные         креативные
```

**Рекомендации по использованию:**

| Тип запроса | Temperature | Причина |
|-------------|-------------|---------|
| Список задач с фактами | 0.3-0.4 | Нужна точность, минимум интерпретации |
| Объяснение задачи | 0.5-0.6 | Баланс между точностью и понятностью |
| Рекомендации по приоритетам | 0.7-0.8 | Нужен анализ и креативный подход |
| Креативный анализ проблем | 0.8-1.0 | Приоритет на нестандартные решения |

**Пример настройки:**
```kotlin
// В Main.kt
TestQuery(
    question = "Покажи все задачи user001",
    temperature = 0.3  // Низкая - точный список без интерпретации
)

TestQuery(
    question = "Какие задачи делать первым?",
    temperature = 0.7  // Средняя - нужны рекомендации
)

TestQuery(
    question = "Как оптимизировать работу команды?",
    temperature = 0.9  // Высокая - нужны креативные идеи
)
```

**Влияние на tool calling:**
- Temperature НЕ влияет на выбор инструментов (модель все равно вызовет нужные)
- Temperature влияет на **интерпретацию** результатов инструментов
- Temperature влияет на **стиль** финального ответа

## Отличия от дня 22

### День 22: Ассистент поддержки
- Работа с тикетами пользователей
- Помощь в решении проблем продукта
- Фокус на поддержку клиентов

### День 23: Ассистент команды разработки
- Работа с задачами разработки
- Управление приоритетами
- Анализ статуса проекта
- Рекомендации по планированию
- Создание новых задач
- Фокус на продуктивность команды

## Результат

Получился полнофункциональный **ассистент команды разработки**, который:

✅ Знает проект через RAG (документация по управлению задачами)
✅ Умеет взаимодействовать с сервисами через MCP (5 tools)
✅ Создает задачи через API
✅ Отвечает на вопросы о статусе проекта
✅ Дает рекомендации по приоритизации задач
✅ Анализирует блокеры и проблемы
✅ Помогает команде планировать работу

**Пример использования:**
```
Вопрос: "Покажи задачи с приоритетом high и предложи, что делать первым"

Ответ ассистента:
1. Анализирует задачи с high приоритетом
2. Проверяет дедлайны и блокеры
3. Дает конкретные рекомендации:
   - Сначала: task008 (code review, дедлайн сегодня)
   - Потом: task001 (баг OAuth, блокирует пользователей)
   - Затем: task002 (фильтрация, важная фича для релиза)
4. Объясняет почему именно в таком порядке
```
